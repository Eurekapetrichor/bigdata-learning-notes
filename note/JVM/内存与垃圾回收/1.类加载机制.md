



# 一、JVM 内存结构
![jvm内存结构](../../../img/jvm/类加载机制/1.jvm内存结构.png)

# 二、类的加载说明
类的加载指的是将 .class 文件(二进制数据) 读取到内存中, 将其放在运行时数据区的方法区内, 然后再堆区创建一个 `java.lang.class` 对象, 用来封装类在方法区内的数据结构。类加载的最终产品是位于堆区的 `Class` 对象, `Class` 对象封装了类在方法区内的数据结构, 并且向 Java 程序员提供了访问方法区内的数据结构的接口。

类加载器并不需要等到某个类被 "首次主动使用" 时再加载, JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它, 如果在预先加载的过程中遇到了 .class 文件缺失或者存在错误, 类加载器必须在程序首次主动使用该类时才报告错误(LinkageError), 如果这个类一直没有被程序主动使用, 那么类加载器就不会报告错误

# 三、加载 .class 的方式
- 从本地系统中直接加载
- 通过网络获取，典型场景： Web Applet
- 从 zip 压缩包中读取，成为日后 jar 、 war 格式的基础
- 运行时计算生成，使用最多的是：动态代理技术
- 由其他文件生成，典型场景： JSP 应用
- 从专有数据库中提取 .class 文件，比较少见从加密文件中获取，典型的防 class 文件被反编译的保护措施

# 四、类加载器子系统
![类加载器与类的加载过程](../../../img/jvm/类加载机制/2.类加载器与类的加载过程.png)

- 类加载器子系统负责从文件系统或者网络中加载 class 文件, class 文件再文件开头有特殊的文件标识。
- ClassLoader 只负责 class 文件的加载, 至于它是否可以运行, 则由 Execution Engine 决定。
- 加载的类信息存放于一块成为方法区的内存空间。出了类的信息外，方法区中还会存放运行时常量池信息，可能包括字符串字面量和数字常量(这部分常量信息是 class 文件中常量池部分的内存映射)

![ClassLoader加载示例](../../../img/jvm/类加载机制/3.ClassLoader加载示例.png)
1. Car.class 存在于本地硬盘上, 可以理解为设计师画在纸上的模板, 而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的示例。
2. Car.class 加载到 JVM 中, 被称为 DNA 元数据模板, 放在方法区。
3. 在 Car.class 文件 -> JVM -> 最终成为元数据模板, 此过程中就要一个运输工具(类装载器 ClassLoader).

# 五、类的加载过程
![类的加载过程](../../../img/jvm/类加载机制/4.类的加载过程.png)


类加载整体分为三个阶段:
1. 加载
2. 链接
   1. 验证
   2. 准备
   3. 解析
3. 初始化

## 5.1 加载
1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为 方法区 的运行时数据结构
3. 在内存中生成一个代表这个类的 `java.lang.Class` 对象, 作为方法区这个类的各种数据的访问入口

## 5.2 链接
### 5.2.1 验证：确保被加载的类的正确性
此阶段主要目的在于确保 .class 文件的字节流中包含信息复合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全

主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证
- 文件格式验证：验证字节流是否符合 Class 文件格式的规范，例如：是否以 `0xCAFEBABE` 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- 元数据验证：对字节码描述的信息进行语义分析, 以保证其描述的信息复合 Java 语言规范的要求。例如：这个类是否有父类，除了 `java.lang.Object` 之外
- 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的
- 符号引用验证：确保解析动作能正确执行。

### 5.2.2 准备: 为类的 `静态变量(类变量)` 分配内存, 并将其初始化为默认值
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
1. 这个时候进行内存分配的，仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 堆 中。
2. 这里所设置的初始值，通常情况下是数据类型的默认值(如：0、0L、null、false等)，而不是被 Java 代码中显示的赋予的值。

关于类变量和实例变量
```java
public class Student {
    private String id;  // 实例变量
    String teacher;     // 实例变量
    private int age;    // 实例变量
    private static String classRoom;  // 类变量(静态变量) 
}
```

假设, 一个类变量的定义为: `public static int val = 3;`

那么变量 val 在准备阶段过后的初始值为0，而不是3，因为这个时候尚未开始执行任何 Java 方法，而把 val 赋值为3的 `public static` 指令是在程序编译后，存放于类构造器 `<clinit>()` 方法之中的，所以把 val 赋值为3的动作将在初始化阶段才执行。

> 说明：
>
> 对于基本数据类型来说，对于类变量和全局变量，如果不显示的对其赋值而直接使用，系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显示的为其赋值，否则编译时不通过。
> 
> 对于同时被 static 和 final 修饰的常量，必须在声明的时候就为其显示的赋值，否则编译不通过；而只被 final 修饰的常量，则既可以在声明时显示的为其赋值，也可以在类初始化时显示的为其赋值，总之，在使用前必须为其显示的赋值，系统不会为其赋予默认零值。
> 
> 如果再数组初始化时没有对数组中的元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。

假设一个常量定义为: `public static final int val = 3;`

在编译时，javac 将会为 val 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 val 赋值为3。可以理解为被 `static final` 修饰的常量，在编译期就将其结果放入了调用它的类的常量池中。

### 5.2.3 解析：把类中的符号引用转为直接引用
解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。

符号引用就是一组符号来描述目标，可以使任何字面量。

直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。


## 5.3 初始化



















