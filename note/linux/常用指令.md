

---
# 1.`uptime`
显示系统的运行时间以及系统在过去 1 分钟、5 分钟和 15 分钟内的平均负载。等同于 `top` 命令的第一行。

```bash
[root@jz-desktop-02 ~]# uptime
 23:35:41 up 44 days,  4:41,  3 users,  load average: 0.59, 0.56, 0.63
```
- `23:35:41`: 当前时间;
- ` up 44 days,  4:41`: 系统运行了 44天4小时41分钟;
- `3 users`: 当前有3个用户登录;
- `load average: 0.59, 0.56, 0.63`: 系统在过去的 1 分钟、5 分钟和 15 分钟内的平均负载。

常用选项
```bash
-p, --pretty
 采用可读友好的格式输出系统已运行时长
-h, --help
 显示帮助信息
-s, --since
 以格式 yyyy-mm-dd HH:MM:SS format 输出系统启动时间
-V, --version
 显示版本信息
```

- `-p`:
    ```bash
    [root@jz-desktop-02 ~]# uptime -p
    up 6 weeks, 2 days, 4 hours, 42 minutes
    ```
- `-s`:
    ```bash
    [root@jz-desktop-02 ~]# uptime -s
    2023-06-25 18:54:12
    ```
  
什么是系统平均负载
> 系统平均负载指单位时间内, 系统中处于 可运行状态 和 不可中断状态的进程数,也就是 平均活跃进程数, 它和 cpu使用率 没有直接的关系.

可运行状态的进程
> 指正在使用 cpu 或正在等待使用 cpu 的进程, 也就是 ps 命令看到的, 处于 R状态(Running or Runnable) 的进程.

不可中断状态的进程
> 指正在等待某些 I/O 的进程, 也就是 ps 命令看到的 D状态(Uninterruptible Sleep, 也称为 Disk Sleep)的进程。 例如等待磁盘 I/O, 当一个进程向磁盘读写数据时, 为了保证数据的一致性, 在得到磁盘回复前, 它是不能被其他进程打断的, 这个时候的进程就处于不可中断状态. 如果此时的进程被打断了, 就容易出现磁盘数据与进程数据不一致的问题。 所以, 不可中断状态实际上是系统对进程和硬件设备的一种保护机制。

系统平均负载多少时合理
> uptime 命令给出的三个时间段的平均负载并不是标准化的, 因为系统中的 cpu 核心数量是不定的. 所以平均负载为 1 意味着拥有 一个cpu核心 的系统一直在忙碌, 而在一个拥有 四个cpu核心 的系统上, 以为着系统 75% 的时间是空闲的。
> 
> 所以，当 系统平均负载 除以 cpu核心数 小于等于1，表示系统没有出现过载的情况。最理想的情况是 每个cpu上都刚好运行一个进程，这样 cpu 就得到了充分的利用。

# 2.`top`
```bash
top - 00:13:47 up 44 days,  5:19,  3 users,  load average: 0.34, 0.43, 0.50
Tasks: 438 total,   1 running, 437 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.4 us,  0.7 sy,  0.0 ni, 97.8 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 65631716 total,   493936 free, 42085480 used, 23052300 buff/cache
KiB Swap: 32964604 total, 31364860 free,  1599744 used. 18945300 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
13336 root      20   0   18.0g   2.1g   6180 S   6.6  3.3   1413:58 java
15756 root      20   0   15.6g   2.9g   8344 S   5.6  4.6   3265:53 ld-linux-x86-64
 8283 10001     20   0   19.3g   1.1g  15668 S   2.6  1.8  78:23.30 sqlservr
23424 impala    20   0   22.6g 524108   8416 S   2.0  0.8 898:36.06 impalad
 4634 10000     20   0 2019808  76372  10780 S   1.6  0.1 297:00.83 harbor_core
 7406 hive      20   0 2797808 643316   6048 S   1.6  1.0   1111:45 java
 5841 200       20   0   13.1g   2.5g   5376 S   1.3  4.0 677:46.53 java
17932 root      20   0   10.8g 775660      0 S   1.3  1.2 647:50.16 java
22034 yarn      20   0 3480388   1.2g   6408 S   1.3  1.9   1103:10 java
29559 hbase     20   0   12.0g   7.9g   6820 S   1.3 12.6 875:48.01 java
 1631 root      20   0 2707556  54028   3016 S   1.0  0.1   3655:28 python
 3732 hive      20   0   26.7g   1.4g   6800 S   1.0  2.3 727:30.33 java
18257 root      20   0    9.8g 873360    616 S   1.0  1.3 677:35.10 java
```
第一行: 和 `uptime` 命令一样.

第二行: 当前系统重任务(进程数)的相关情况, 
> `438 total`: 系统当前一共有 652 个进程.
> `1 running`: 有一个进程正在执行.
> `437 sleeping`: 有 437 个进程处于睡眠状态, 也就是不需要使用 cpu 的状态.
> `0 stopped`: 有 0 个进程处于 `stopped` 状态, 这个状态就是被停下来的进程, 比如通过 ctrl+z 让一个进程停下来, 你可以通过给这个进程发送一个信号 SIGCONT 让这个进程恢复执行.
> `0 zombie`: 有 0 个僵尸进程, 僵尸进程就是一个进程执行完了, 但是其父进程还没来得及处理子进程的退出状态信息(成为"退出状态码" 或 "退出码").

第三行:
> - `us`: 用户空间占用 CPU 百分比.
> - `sy`: 内核空间占用 CPU 百分比.
> - `ni`: 用户进程空间内改变过优先级的进程占用 CPU 百分比.
> - `id`: 空闲CPU百分比.
> - `wa`: 等待输入输入的CPU百分比.
> - `hi`: 硬中断占用CPU百分比.
> - `si`: 软中断CPU百分比.
> - `st`: 虚拟CPU等待实际CPU的时间的百分比.

一般关注的多的是 `us`、`sy`、`id`、`wa`、`hi`、`wi` 这 6 个数值, 需要注意的指标如下:
- CPU(s): 表示当前 cpu 的平均值, 默认 top 命令配置显示的事平均的 cpu 使用情况, 按键盘1可以显示各个逻辑 cpu 的使用情况
  ```bash
  top - 00:42:44 up 44 days,  5:48,  3 users,  load average: 0.43, 0.42, 0.50
  Tasks: 438 total,   1 running, 437 sleeping,   0 stopped,   0 zombie
  %Cpu0  :  7.0 us,  1.0 sy,  0.0 ni, 89.9 id,  1.7 wa,  0.0 hi,  0.3 si,  0.0 st
  %Cpu1  :  2.0 us,  1.0 sy,  0.0 ni, 88.6 id,  8.4 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu2  :  1.7 us,  1.0 sy,  0.0 ni, 96.6 id,  0.7 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu3  :  2.0 us,  0.7 sy,  0.0 ni, 97.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu4  :  3.4 us,  2.0 sy,  0.0 ni, 92.6 id,  2.0 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu5  :  2.7 us,  1.0 sy,  0.0 ni, 81.3 id, 15.0 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu6  :  6.0 us,  4.7 sy,  0.0 ni, 77.5 id, 11.7 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu7  :  2.3 us,  1.7 sy,  0.0 ni, 77.9 id, 17.7 wa,  0.0 hi,  0.3 si,  0.0 st
  %Cpu8  :  0.3 us,  0.0 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu9  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu10 :  6.3 us,  1.0 sy,  0.0 ni, 92.4 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu11 :  0.7 us,  0.3 sy,  0.0 ni, 99.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu12 :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu13 :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu14 :  0.0 us,  0.3 sy,  0.0 ni, 90.7 id,  9.0 wa,  0.0 hi,  0.0 si,  0.0 st
  %Cpu15 :  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
  KiB Mem : 65631716 total,   440220 free, 42104888 used, 23086608 buff/cache
  KiB Swap: 32964604 total, 31364860 free,  1599744 used. 18925900 avail Mem
  ```
  - 统计**空闲的 cpu 利用率**, 直接统计 `%id` 即可, 当 id 持续过低的时候, 表示系统迫切需要解决 cpu 资源问题.
  - 统计**cpu使用率**, 使用 `1-%id` 获取, 或者 `us+sy+si`.
  - wa: 使用率过高的时候, 需要考虑 IO 的性能是否有瓶颈, 可以在使用 iostat、sar 等命令进一步分析.
  - hi: 使用率过高时, 表示当前硬件中断占用很大的百分比, 一般硬件中断可以分析文件 `/proc/interrupts`、`/proc/irq/pid/smp_affinity`、服务 `irqbalance` 是否配置，以及 cpu 的频率设置, 通过这些可以帮助系统打散优化系统的硬件中断.
  - si: 常见的软终端一般都是和网络有关. 从网卡到IP层的数据报文收发都是si处理的,长时间写日志也可能产生软中断. 当软终端出现瓶颈的时候, 系统有个进行叫 `ksoftirqd`, 每个cpu都有自己对应的 `ksoftirqd/n(n为cpu的逻辑id)`,每个 `ksoftirqd` 的内核线程都会去运行对应的 `ksoftirqd(函数)` 来处理自己的终端队列上的软件中断. 所以, 当网络出现阻塞的时候, 软件中断程序 `ksoftirqd` 肯定会出现瓶颈. 此时可以通过 `ps -aux|grep ksoftirqd` 查看 `ksoftirqd` 的瓶颈.

第四行: 内存的使用情况
> - `total`: 总共有 65631716kb 的内存.
> - `free`: 还有 493936kb 的内存没有使用.
> - `used`: 使用了 42085480kb 的内存.
> - `buff/cache`: 用于缓存的物理内存大小.

第五行: 交换分区的使用情况, 交换分区就是当操作系统发现内存满了之后, 操作系统会选择部分不常使用的页面将它放到磁盘中，需要使用的时候再将这部分数据从磁盘中读取出来.
> - `total`: 总共有 32964604kb 的交换内存.
> - `free`: 还有 31364860kb 的交换内存没有使用.
> - `used`: 使用了 1599744kb 的交换内存.
> - `avail Mem`: 可用于启动新程序的内存大小估值.

第七行: 各进程（任务）的状态监控
> - `PID`: 进程id.
> - `USER`: 进程所有者.
> - `PR`: 进程优先级.
> - `NI`: nice值, 负值表示高优先级, 正直表示低优先级.
> - `VIRT`: 进程使用的虚拟内存总量, 单位kb. VIRT=SWAP+RES.
> - `RES`: 进程使用的、未被交换出的物理内存大小, 单位kb. RES=CODE+DATA
> - `SHR`: 共享内存大小,单位kb.
> - `S`: 进程状态. D:不可中断的睡眠状态; R:运行; S:睡眠; T:跟踪/停止; Z:僵尸进程.
> - `%CPU`: 上次更新到现在的 CPU 时间占用百分比.
> - `%MEM`: 进程使用的物理内存百分比.
> - `TIME`: 进程使用的CPU时间总计, 单位1/100秒.
> - `COMMAND`: 进程名称(命令名/命令行).












