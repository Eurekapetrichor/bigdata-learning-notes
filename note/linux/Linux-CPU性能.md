

---


# 一、平均负载
## 1.1 查看系统负载
当发现系统变慢的时候, 通常都会使用 `top` 或 `uptime` 查看系统负载情况:
```bash
# top
[root@k8s-master ~]# top
top - 11:24:51 up 59 min,  2 users,  load average: 0.32, 0.24, 0.18
...

# uptime
[root@k8s-master ~]# uptime
 11:24:51 up 59 min,  2 users,  load average: 0.32, 0.24, 0.18
```
各个值的说明:
- 11:24:51: 系统时间
- up 59 min: 系统运行时间
- 2 users: 登录到系统的人数
- 0.32, 0.24, 0.18: 分别代表过去1、5、15分钟的**平均负载(Load Average)**
    
## 1.2 平均负载的介绍

关于平均负载的详细解释可以使用: `man uptime` 查看官方解释;

简单来说, 平均负载是指单位时间内, 系统处于**可运行状态**和**不可中断状态**的平均进程数, 也就是**平均活跃进程数**, 它和 CPU 使用率并没有直接关系。
- 可运行状态: 正在使用 CPU 或正在等待CPU的进程, 就是 `ps -aux` 命令看到的那些处于 R 的进程;
- 不可中断状态: 整处在内核关键状态的进程, 通常都是不可被打断的进程, 例如等待设备I/O响应 的, 也就是 `ps -aux` 命令处于 D 状态的进程.

平均负载其实就是平均活跃的进程数(如上面解释, 包括可运行状态进程、不可中断状态进程), 包括等待I/O的进程, 也就是说 I/O 操作也会造成平均负载增高.

## 1.3 平均负载合理值范围
既然平均负载是活跃的进程数, 那么最理想的就是每个CPU上都运行这一个进程, 这样每个 CPU 都得到充分的利用

例如: 平均负载为2, 代表着:
- 在只有两个CPU的系统上, 代表所有CPU的负载都刚好被占用完;
- 在只有四个CPU的系统上, 代表CPU有一半的空闲;
- 在只有一个CPU的系统上, 代表有一半的进程得不到CPU, 一直在相互竞争CPU的使用权;

所以得出结论: 平均负载最理想就是=CPU个数

首先我们通过如下命令查看CPU个数:
```bash
[root@k8s-master ~]# cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l
2
```
有了CPU个数, 就可以通过 `top` 或 `uptime` 判断出平均负载的情况了

关于这个命令显示的最后三个参数(1、5、15分钟的平均负载), 再做如下解释:
- 当 1分钟负载小于 15分钟负载时: 表示服务器负载情况正在降低;
- 当 1分钟负载基本等于 15分钟负载时: 表示服务器负载情况很稳定;
- 当 1分钟负载大于 15分钟负载时: 表示服务器负载情况正在上升, 这种情况是我们需要注意的, 因为这种增加可能是暂时的, 也可能回一直增加下去, 一旦 1分钟负载超过(接近)了 CPU个数, 就意味着发生过载.

在实际上产环境中, **当平均负载高于CPU数量70%的时候**, 就需要查负载高的问题了, 因为一旦负载高, 意味着进程相应慢, 影响服务的功能.

## 1.4 平均负载和CPU使用率
工作中, 人们通常容易将平均负载和CPU使用率搞混

两者说明:
- 平均负载: 单位时间内的活跃进程数, 包括了正在使用CPU进程, 还包括正在等待CPU, 正在等待I/O的进程;
- CPU使用率: 单位时间内CPU的繁忙情况

两者对比举例:
- CPU密集型: 大量的使用CPU会导致平均负载升高, 此时平均负载和CPU使用率是一致的;
- I/O密集型: 大量的I/O操作也会造成平均负载升高, 但是CPU使用率不一定高, 此时平均负载和CPU使用率是不一样的;
- 大量等待CPU的进程调度也会导致平均负载升高, 此时CPU的使用率也会升高;

## 1.5 平均负载案例分析
> 准备工作

环境: CentOS7.8一台
配置: 2CPU, 2GB内存
需要软件: stress 和 sysstat

> 说明

stress 是一个 Linux 系统压力测试工具, 模拟平均负载升高的场景 

sysstat 包含了常用的 Linux 性能工具, 用来监控和分析系统的性能

> 场景一: CPU密集型
> - 在第一个窗口运行如下命令, 模拟一个CPU使用率100%的场景
>    ```bash
>   [root@k8s-master ~]# stress --cpu 1 --timeout 600
>   ```    
> - 在第二个窗口运行 uptime 查看平均负载的变化情况
>   ```bash
>   [root@k8s-master ~]# uptime
>     14:43:25 up  4:18,  4 users,  load average: 1.00, 0.73, 0.30
>   ```
> - 在第三个窗口运行 mpstat 查看 CPU使用率的变化情况
>   ```bash
>   # -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
>   [root@k8s-master ~]# mpstat -P ALL 5
>    Linux 3.10.0-1127.18.2.el7.x86_64 (k8s-master) 	2020年11月13日 	_x86_64_	(2 CPU)
>    
>    14时46分07秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
>     14时46分12秒  all   52.13    0.00    0.61    0.00    0.00    0.10    0.00    0.00    0.00   47.17
>     14时46分12秒    0  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
>     14时46分12秒    1    3.08    0.00    1.23    0.00    0.00    0.00    0.00    0.00    0.00   95.69
>   ```
>
> 从第二个窗口可以看到, 1分钟的平均负载会慢慢增加到1, 从终端二可以看到, 有一个CPU的使用率正好是100%, 但是他的 iowait 却是 0, 这说明, 平均负载的升高正是由于CPU使用率为100%
>
> - 使用 `pidstat` 来查询CPU使用率高的进程
>   ```bash
>   # 间隔5秒后输出一组数据
>   [root@k8s-master ~]# pidstat -u 5 1
>     Linux 3.10.0-1127.18.2.el7.x86_64 (k8s-master) 	2020年11月13日 	_x86_64_	(2 CPU)
>     
>     14时50分29秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
>     14时50分34秒     0       412    0.00    0.20    0.00    0.20     1  xfsaild/dm-0
>     14时50分34秒     0       667    0.80    0.20    0.00    1.00     0  kubelet
>     14时50分34秒     0      1077    0.40    0.00    0.00    0.40     0  dockerd
>     14时50分34秒     0      2185    0.20    0.20    0.00    0.40     1  kube-controller
>     14时50分34秒     0      2213    0.20    0.00    0.00    0.20     1  kube-scheduler
>     14时50分34秒     0      2215    0.20    0.60    0.00    0.80     1  etcd
>     14时50分34秒     0      2574    0.80    0.60    0.00    1.40     0  kube-apiserver
>     14时50分34秒     0      2803    0.20    0.00    0.00    0.20     0  kube-proxy
>     14时50分34秒     0    105775  100.00    0.00    0.00  100.00     0  stress
>     14时50分34秒     0    108308    0.00    0.20    0.00    0.20     1  pidstat
>     
>     平均时间:   UID       PID    %usr %system  %guest    %CPU   CPU  Command
>     平均时间:     0       412    0.00    0.20    0.00    0.20     -  xfsaild/dm-0
>     平均时间:     0       667    0.80    0.20    0.00    1.00     -  kubelet
>     平均时间:     0      1077    0.40    0.00    0.00    0.40     -  dockerd
>     平均时间:     0      2185    0.20    0.20    0.00    0.40     -  kube-controller
>     平均时间:     0      2213    0.20    0.00    0.00    0.20     -  kube-scheduler
>     平均时间:     0      2215    0.20    0.60    0.00    0.80     -  etcd
>     平均时间:     0      2574    0.80    0.60    0.00    1.40     -  kube-apiserver
>     平均时间:     0      2803    0.20    0.00    0.00    0.20     -  kube-proxy
>     平均时间:     0    105775  100.00    0.00    0.00  100.00     -  stress
>     平均时间:     0    108308    0.00    0.20    0.00    0.20     -  pidstat
>   ```
>
> 可以看见, CPU使用最高的就是 stress了

> 场景二: I/O 密集型
> - 安装 stress-ng:
>    ```bash
>    yum install -y epel-release.noarch && yum -y update
>    yum install -y stress stress-ng
>    ```
> - 在第一个窗口运行如下命令, 模拟一个CPU使用率100%的场景
>    ```bash
>   [root@k8s-master ~]# stress-ng -i 1 --hdd 1 --timeout 600
>    stress-ng: info:  [4826] dispatching hogs: 1 hdd, 1 io
>   ```    
> - 在第二个窗口运行 uptime 查看平均负载的变化情况
>   ```bash
>   [root@k8s-master ~]# uptime
>     15:21:28 up  4:56,  4 users,  load average: 8.40, 5.74, 3.21
>   ```
> - 在第三个窗口运行 mpstat(或者 `pidstat -d`) 查看 CPU 和 I/O 使用率的变化情况
>   ```bash
>   [root@k8s-master stress-ng-0.11.23]# mpstat -P ALL 5 20
>    Linux 3.10.0-1127.18.2.el7.x86_64 (k8s-master) 	2020年11月13日 	_x86_64_	(2 CPU)
>    
>    15时19分08秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
>    15时19分13秒  all    3.35    0.00    5.66   87.32    0.00    3.46    0.00    0.00    0.00    0.21
>    15时19分13秒    0    3.80    0.00    5.91   85.65    0.00    4.01    0.00    0.00    0.00    0.63
>    15时19分13秒    1    2.92    0.00    5.21   88.96    0.00    2.92    0.00    0.00    0.00    0.00
>   ```
> 从第二个窗口可以看到, 1分钟平均负载会慢慢升到1甚至更多, 从第三个窗口可以看到, CPU的使用率只有不到6%, 但是磁盘I/O高达89%, 说明, 平均负载的升高是因为iowait的升高
>
> - 使用 `pidstat` 来查询CPU使用率高的进程
>    ```bash
>    # 每5秒打印一次
>    [root@k8s-master stress-ng-0.11.23]# pidstat -u 5 1
>     Linux 3.10.0-1127.18.2.el7.x86_64 (k8s-master) 	2020年11月13日 	_x86_64_	(2 CPU)
>     
>     15时24分55秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
>     15时25分00秒     0         6    0.00    1.20    0.00    1.20     0  ksoftirqd/0
>     15时25分00秒     0         9    0.00    0.20    0.00    0.20     1  rcu_sched
>     15时25分00秒     0        14    0.00    0.40    0.00    0.40     1  ksoftirqd/1
>     15时25分00秒     0        35    0.00    3.20    0.00    3.20     1  kswapd0
>     15时25分00秒     0       412    0.00    0.20    0.00    0.20     1  xfsaild/dm-0
>     15时25分00秒     0       667    1.00    1.20    0.00    2.20     1  kubelet
>     15时25分00秒     0       680    0.20    0.20    0.00    0.40     0  vmtoolsd
>     15时25分00秒     0       973    0.20    0.20    0.00    0.40     1  containerd
>     15时25分00秒     0      1077    3.00    0.60    0.00    3.60     0  dockerd
>     15时25分00秒     0      2215    0.40    0.80    0.00    1.20     0  etcd
>     15时25分00秒     0      2574    0.80    1.60    0.00    2.40     0  kube-apiserver
>     15时25分00秒     0      2803    0.00    0.40    0.00    0.40     1  kube-proxy
>     15时25分00秒     0      3200    0.00    4.60    0.00    4.60     0  kworker/u256:3
>     15时25分00秒     0      3704    0.00    0.80    0.00    0.80     0  kworker/0:2
>     15时25分00秒     0      5403    0.00    0.40    0.00    0.40     1  kworker/1:3
>     15时25分00秒     0      5584    0.00    0.80    0.00    0.80     1  kube-scheduler
>     15时25分00秒     0      5592    0.40    0.80    0.00    1.20     1  kube-controller
>     15时25分00秒     0      6744    0.20   29.80    0.00   30.00     1  stress-ng-hdd
>     15时25分00秒     0      6745    0.20   13.00    0.00   13.20     0  stress-ng-io
>     15时25分00秒     0      7009    0.20    0.00    0.00    0.20     0  watch
>     15时25分00秒     0    117049    0.00   12.60    0.00   12.60     1  kworker/u256:2
>     
>     平均时间:   UID       PID    %usr %system  %guest    %CPU   CPU  Command
>     平均时间:     0         6    0.00    1.20    0.00    1.20     -  ksoftirqd/0
>     平均时间:     0         9    0.00    0.20    0.00    0.20     -  rcu_sched
>     平均时间:     0        14    0.00    0.40    0.00    0.40     -  ksoftirqd/1
>     平均时间:     0        35    0.00    3.20    0.00    3.20     -  kswapd0
>     平均时间:     0       412    0.00    0.20    0.00    0.20     -  xfsaild/dm-0
>     平均时间:     0       667    1.00    1.20    0.00    2.20     -  kubelet
>     平均时间:     0       680    0.20    0.20    0.00    0.40     -  vmtoolsd
>     平均时间:     0       973    0.20    0.20    0.00    0.40     -  containerd
>     平均时间:     0      1077    3.00    0.60    0.00    3.60     -  dockerd
>     平均时间:     0      2215    0.40    0.80    0.00    1.20     -  etcd
>     平均时间:     0      2574    0.80    1.60    0.00    2.40     -  kube-apiserver
>     平均时间:     0      2803    0.00    0.40    0.00    0.40     -  kube-proxy
>     平均时间:     0      3200    0.00    4.60    0.00    4.60     -  kworker/u256:3
>     平均时间:     0      3704    0.00    0.80    0.00    0.80     -  kworker/0:2
>     平均时间:     0      5403    0.00    0.40    0.00    0.40     -  kworker/1:3
>     平均时间:     0      5584    0.00    0.80    0.00    0.80     -  kube-scheduler
>     平均时间:     0      5592    0.40    0.80    0.00    1.20     -  kube-controller
>     平均时间:     0      6744    0.20   29.80    0.00   30.00     -  stress-ng-hdd
>     平均时间:     0      6745    0.20   13.00    0.00   13.20     -  stress-ng-io
>     平均时间:     0      7009    0.20    0.00    0.00    0.20     -  watch
>     平均时间:     0    117049    0.00   12.60    0.00   12.60     -  kworker/u256:2
>    ```
>  
> 可以看到, 此次 平均负载过高是因为 stress 造成的

> 场景三: 大量进程的场景
> - 说明:
>   当系统中运行的进程超出CPU运行能力时, 就会出现等待CPU的情况
> - 升级 sysstat
>   ```bash
>   # 卸载已经有的低版本sysstat
>   $ rpm -e --nodeps sysstat
>   # 下载sysstat
>   http://sebastien.godard.pagesperso-orange.fr/download.html
>   # 解压
>   $ tar -zxvf sysstat-12.4.0.tar.gz
>   # 安装gcc
>   $ yum -y install gcc
>   # 安装sysstat
>   $ cd sysstat-12.4.0
>   $ ./configure
>   $ make
>   $ make install
>   # 配置软连接
>   $ ln -s /usr/local/bin/* /usr/bin/
>   ```
>
> - 在第一个窗口运行如下命令, 模拟8个进程
>   ```bash
>   [root@k8s-master ~]# stress -c 8 --timeout 600
>    stress: info: [9121] dispatching hogs: 8 cpu, 0 io, 0 vm, 0 hdd
>   ```
> - 在第二个窗口运行uptime, 查看系统平均负载
>   ```bash
>   [root@k8s-master ~]# uptime
>     15:32:39 up  5:07,  4 users,  load average: 9.01, 5.03, 3.63
>   ```
> 由于系统只有2个CPU, 比需要的8个进程少, 系统从而处于严重过载的状态, 平均负载高达 9.01
> 
> - 使用 `pidstat` 来查询CPU使用率高的进程
>   ```bash
>   # 每5秒打印一次
>   [root@k8s-master stress-ng-0.11.23]# pidstat -u 5 1
>    Linux 3.10.0-1127.18.2.el7.x86_64 (k8s-master) 	2020年11月13日 	_x86_64_	(2 CPU)
>    
>    16时15分47秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
>    16时15分52秒     0       667    0.60    0.20    0.00    0.60    0.80     0  kubelet
>    16时15分52秒     0      1077    0.60    0.00    0.00    0.00    0.60     0  dockerd
>    16时15分52秒     0      2215    0.40    0.60    0.00    0.00    1.00     0  etcd
>    16时15分52秒     0      2574    0.80    0.80    0.00    0.00    1.60     0  kube-apiserver
>    16时15分52秒     0      2962    0.00    0.20    0.00    0.00    0.20     1  flanneld
>    16时15分52秒     0      5403    0.00    0.20    0.00    0.60    0.20     1  kworker/1:3
>    16时15分52秒     0      7319    0.20    0.60    0.00    1.60    0.80     1  kube-controller
>    16时15分52秒     0     27789   23.35    0.00    0.00   76.85   23.35     1  stress
>    16时15分52秒     0     27790   22.16    0.00    0.00   77.64   22.16     1  stress
>    16时15分52秒     0     27791   22.55    0.00    0.00   77.45   22.55     0  stress
>    16时15分52秒     0     27792   26.75    0.00    0.00   73.05   26.75     0  stress
>    16时15分52秒     0     27793   28.54    0.00    0.00   71.06   28.54     0  stress
>    16时15分52秒     0     27794   22.75    0.00    0.00   77.05   22.75     0  stress
>    16时15分52秒     0     27795   24.55    0.00    0.00   75.25   24.55     1  stress
>    16时15分52秒     0     27796   23.55    0.00    0.00   77.25   23.55     1  stress
>    16时15分52秒     0     27869    0.20    0.20    0.00    0.20    0.40     1  watch
>    16时15分52秒     0     27941    0.00    0.20    0.00    0.20    0.20     0  pidstat
>   ```
> 可以看到, 8 个stress进程争抢 2 个CPU, 每个进程等待的时间(%wait)高达 77%. 这些超出CPU计算能力的进程, 最终导致CPU过载.


# 二、CPU上下文切换

# 三、CPU使用100%

# 四、Linux软中断

# 五、快速分析CPU瓶颈

# 六、CPU性能分析的思路