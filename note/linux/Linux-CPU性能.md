

---


# 一、平均负载
## 1.1 查看系统负载
当发现系统变慢的时候, 通常都会使用 `top` 或 `uptime` 查看系统负载情况:
```bash
# top
[root@k8s-master ~]# top
top - 11:24:51 up 59 min,  2 users,  load average: 0.32, 0.24, 0.18
...

# uptime
[root@k8s-master ~]# uptime
 11:24:51 up 59 min,  2 users,  load average: 0.32, 0.24, 0.18
```
各个值的说明:
- 11:24:51: 系统时间
- up 59 min: 系统运行时间
- 2 users: 登录到系统的人数
- 0.32, 0.24, 0.18: 分别代表过去1、5、15分钟的**平均负载(Load Average)**
    
## 1.2 平均负载的介绍

关于平均负载的详细解释可以使用: `man uptime` 查看官方解释;

简单来说, 平均负载是指单位时间内, 系统处于**可运行状态**和**不可中断状态**的平均进程数, 也就是**平均活跃进程数**, 它和 CPU 使用率并没有直接关系。
- 可运行状态: 正在使用 CPU 或正在等待CPU的进程, 就是 `ps -aux` 命令看到的那些处于 R 的进程;
- 不可中断状态: 整处在内核关键状态的进程, 通常都是不可被打断的进程, 例如等待设备I/O响应 的, 也就是 `ps -aux` 命令处于 D 状态的进程.

平均负载其实就是平均活跃的进程数(如上面解释, 包括可运行状态进程、不可中断状态进程), 包括等待I/O的进程, 也就是说 I/O 操作也会造成平均负载增高.

## 1.3 平均负载合理值范围
既然平均负载是活跃的进程数, 那么最理想的就是每个CPU上都运行这一个进程, 这样每个 CPU 都得到充分的利用

例如: 平均负载为2, 代表着:
- 在只有两个CPU的系统上, 代表所有CPU的负载都刚好被占用完;
- 在只有四个CPU的系统上, 代表CPU有一半的空闲;
- 在只有一个CPU的系统上, 代表有一半的进程得不到CPU, 一直在相互竞争CPU的使用权;

所以得出结论: 平均负载最理想就是=CPU个数

首先我们通过如下命令查看CPU个数:
```bash
[root@k8s-master ~]# cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l
2
```
有了CPU个数, 就可以通过 `top` 或 `uptime` 判断出平均负载的情况了

关于这个命令显示的最后三个参数(1、5、15分钟的平均负载), 再做如下解释:
- 当 1分钟负载小于 15分钟负载时: 表示服务器负载情况正在降低;
- 当 1分钟负载基本等于 15分钟负载时: 表示服务器负载情况很稳定;
- 当 1分钟负载大于 15分钟负载时: 表示服务器负载情况正在上升, 这种情况是我们需要注意的, 因为这种增加可能是暂时的, 也可能回一直增加下去, 一旦 1分钟负载超过(接近)了 CPU个数, 就意味着发生过载.

在实际上产环境中, **当平均负载高于CPU数量70%的时候**, 就需要查负载高的问题了, 因为一旦负载高, 意味着进程相应慢, 影响服务的功能.

## 1.4 平均负载和CPU使用率
工作中, 人们通常容易将平均负载和CPU使用率搞混

两者说明:
- 平均负载: 单位时间内的活跃进程数, 包括了正在使用CPU进程, 还包括正在等待CPU, 正在等待I/O的进程;
- CPU使用率: 单位时间内CPU的繁忙情况

两者对比举例:
- CPU密集型: 大量的使用CPU会导致平均负载升高, 此时平均负载和CPU使用率是一致的;
- I/O密集型: 大量的I/O操作也会造成平均负载升高, 但是CPU使用率不一定高, 此时平均负载和CPU使用率是不一样的;
- 大量等待CPU的进程调度也会导致平均负载升高, 此时CPU的使用率也会升高;

## 1.5 平均负载案例分析
> 准备工作

环境: CentOS7.8一台
配置: 2CPU, 2GB内存
需要软件: stress 和 sysstat

> 说明

stress 是一个 Linux 系统压力测试工具, 模拟平均负载升高的场景 

sysstat 包含了常用的 Linux 性能工具, 用来监控和分析系统的性能

> 场景一: CPU密集型
> - 在第一个窗口运行如下命令, 模拟一个CPU使用率100%的场景
>    ```bash
>   [root@k8s-master ~]# stress --cpu 1 --timeout 600
>   ```    
> - 在第二个窗口运行 uptime 查看平均负载的变化情况
>   ```bash
>   [root@k8s-master ~]# uptime
>     14:43:25 up  4:18,  4 users,  load average: 0.18, 0.23, 0.20
>   ```
> - 在第三个窗口运行 mpstat 查看 CPU使用率的变化情况
>   ```bash
>   # -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
>   [root@k8s-master ~]# mpstat -P ALL 5
>    Linux 3.10.0-1127.18.2.el7.x86_64 (k8s-master) 	2020年11月13日 	_x86_64_	(2 CPU)
>    
>    14时46分07秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
>     14时46分12秒  all   52.13    0.00    0.61    0.00    0.00    0.10    0.00    0.00    0.00   47.17
>     14时46分12秒    0  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
>     14时46分12秒    1    3.08    0.00    1.23    0.00    0.00    0.00    0.00    0.00    0.00   95.69
>   ```
>
> 从第二个窗口可以看到, 1分钟的平均负载会慢慢增加到1, 从终端二可以看到, 有一个CPU的使用率正好是100%, 但是他的 iowait 却是 0, 这说明, 平均负载的升高正是由于CPU使用率为100%




# 二、CPU上下文切换

# 三、CPU使用100%

# 四、Linux软中断

# 五、快速分析CPU瓶颈

# 六、CPU性能分析的思路